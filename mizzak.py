import discord
import discord.errors
from discord.ext import commands
from discord import app_commands
import yt_dlp
import asyncio
import json
import sys
import os
import difflib

# --- Configuration & Secrets ---
# Load token from the secrets.json file generated by the batch script
try:
    with open('secrets.json', 'r') as f:
        secrets = json.load(f)
        TOKEN = secrets['BOT_TOKEN']
except FileNotFoundError:
    print("CRITICAL ERROR: secrets.json not found!")
    print("Please run the batch script first to generate your API key file.")
    sys.exit(1)
except KeyError:
    print("CRITICAL ERROR: BOT_TOKEN not found in secrets.json!")
    print("Please delete secrets.json and run the batch script again.")
    sys.exit(1)

# --- Persistence ---
GUILD_SETTINGS_FILE = 'guild_settings.json'
guild_settings = {}

def load_settings():
    global guild_settings
    if os.path.exists(GUILD_SETTINGS_FILE):
        try:
            with open(GUILD_SETTINGS_FILE, 'r') as f:
                guild_settings = json.load(f)
        except json.JSONDecodeError:
            print("Error decoding guild_settings.json. Starting with empty settings.")
            guild_settings = {}
    else:
        guild_settings = {}

def save_settings():
    with open(GUILD_SETTINGS_FILE, 'w') as f:
        json.dump(guild_settings, f, indent=4)

# Required to prevent the stream from dropping out
FFMPEG_OPTIONS = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn'
}

YTDL_OPTIONS = {
    'format': 'bestaudio/best',
    'noplaylist': True,
    'quiet': True,
    'no_warnings': True,
}

# --- State Management (Per-Guild) ---
guild_queues = {}
guild_skip_votes = {}
guild_skip_percents = {} # Default will be 0.25 (25%)

class Bot(commands.Bot):
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        intents.members = True
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        await self.tree.sync()

    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.CommandNotFound):
            return
        raise error

bot = Bot()

# --- UI Elements ---
class SkipButton(discord.ui.View):
    def __init__(self, guild_id, voice_client):
        super().__init__(timeout=None)
        self.guild_id = guild_id
        self.voice_client = voice_client

    @discord.ui.button(label="Skip", emoji="‚è≠Ô∏è", style=discord.ButtonStyle.primary)
    async def skip(self, interaction: discord.Interaction, button: discord.ui.Button):
        vc = self.voice_client
        guild_id = self.guild_id

        if not vc or not vc.is_connected() or not vc.is_playing():
            await interaction.response.send_message("Nothing is playing right now.", ephemeral=True)
            return

        # Ensure user is actually listening
        if not interaction.user.voice or interaction.user.voice.channel != vc.channel:
            await interaction.response.send_message("You must be in the voice channel to vote!", ephemeral=True)
            return

        # Initialize vote set if empty
        if guild_id not in guild_skip_votes:
            guild_skip_votes[guild_id] = set()

        if interaction.user.id in guild_skip_votes[guild_id]:
            await interaction.response.send_message("You've already voted to skip this track.", ephemeral=True)
            return

        guild_skip_votes[guild_id].add(interaction.user.id)

        # Calculate votes needed (exclude bots from total listener count)
        listeners = [m for m in vc.channel.members if not m.bot]
        required_percent = guild_skip_percents.get(guild_id, 0.25)
        required_votes = max(1, int(len(listeners) * required_percent))
        current_votes = len(guild_skip_votes[guild_id])

        if current_votes >= required_votes:
            await interaction.response.send_message(f"‚è≠Ô∏è Skip vote passed ({current_votes}/{required_votes}). Skipping...")
            vc.stop() # Triggers the 'after' callback in play_next()
        else:
            await interaction.response.send_message(f"Skip vote registered! ({current_votes}/{required_votes} needed)")


class PlaylistView(discord.ui.View):
    def __init__(self, queue, page=0):
        super().__init__(timeout=60)
        self.queue = queue
        self.page = page
        self.items_per_page = 10
        self.update_buttons()

    def update_buttons(self):
        self.previous.disabled = self.page == 0
        self.next.disabled = (self.page + 1) * self.items_per_page >= len(self.queue)

    @discord.ui.button(label="Previous", style=discord.ButtonStyle.primary)
    async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page -= 1
        self.update_buttons()
        await interaction.response.edit_message(embed=self.create_embed(), view=self)

    @discord.ui.button(label="Next", style=discord.ButtonStyle.primary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page += 1
        self.update_buttons()
        await interaction.response.edit_message(embed=self.create_embed(), view=self)

    def create_embed(self):
        start = self.page * self.items_per_page
        end = start + self.items_per_page
        current_items = self.queue[start:end]
        
        embed = discord.Embed(title="üéµ Current Queue", color=discord.Color.blue())
        
        if not current_items:
            embed.description = "Queue is empty."
        else:
            description = ""
            for i, song in enumerate(current_items, start=start + 1):
                description += f"**{i}.** {song['title']}\n"
            embed.description = description
            
        embed.set_footer(text=f"Page {self.page + 1}/{(len(self.queue) - 1) // self.items_per_page + 1} ‚Ä¢ Total Songs: {len(self.queue)}")
        return embed

class TrackSelectionView(discord.ui.View):
    def __init__(self, entries, vc, interaction):
        super().__init__(timeout=60)
        self.entries = entries
        self.vc = vc
        self.interaction = interaction
        
        # Limit entries to 5
        options = []
        for i, entry in enumerate(entries[:5]):
            label = entry.get('title', 'Unknown Title')[:100]
            uploader = entry.get('uploader', 'Unknown Artist')
            description = f"{uploader}"[:100]
            options.append(discord.SelectOption(label=label, description=description, value=str(i)))

        # Create the Select item dynamically and add it
        select = discord.ui.Select(placeholder="Select a track to play...", min_values=1, max_values=1, options=options)
        
        async def select_callback(interaction: discord.Interaction):
            await interaction.response.defer() # Acknowledge the interaction
            
            selected_index = int(select.values[0])
            selected_track = self.entries[selected_index]
            
            title = selected_track.get('title', 'Unknown Track')
            url = selected_track.get('url')
            guild_id = interaction.guild.id

            # Initialize queue if needed
            if guild_id not in guild_queues:
                guild_queues[guild_id] = []

            guild_queues[guild_id].append({'url': url, 'title': title})

            if not self.vc.is_playing():
                await interaction.followup.send(f"Selected and starting: **{title}**")
                play_next(guild_id, self.vc, interaction.channel)
            else:
                await interaction.followup.send(f"Selected and added to queue: **{title}**")
            
            # Stop the view to remove interaction
            self.stop()
            # Disable the select menu visually
            select.disabled = True
            await self.interaction.edit_original_response(view=self)

        select.callback = select_callback
        self.add_item(select)
    
    async def on_timeout(self):
        # Disable all items on timeout
        for item in self.children:
            item.disabled = True
        try:
            await self.interaction.edit_original_response(view=self)
        except:
            pass


# --- Audio Player Logic ---
def check_confidence(query, title):
    query = query.lower()
    title = title.lower()
    
    # 1. Exact substring match (handles "bad romance" -> "lady gaga - bad romance")
    if query in title:
        return 1.0
        
    # 2. Token overlap (handles "lady gaga bad romance" -> "lady gaga - bad romance")
    query_tokens = set(query.split())
    title_tokens = set(title.split())
    
    if not query_tokens: 
        return 0.0
        
    intersection = query_tokens.intersection(title_tokens)
    overlap_ratio = len(intersection) / len(query_tokens)
    
    if overlap_ratio >= 1.0: # All query words found in title
        return 1.0
    
    # 3. Stripped match (handles "pokerface" -> "poker face")
    # Remove all non-alphanumeric characters to catch compound words/typos
    query_stripped = "".join(filter(str.isalnum, query))
    title_stripped = "".join(filter(str.isalnum, title))
    
    if query_stripped and query_stripped in title_stripped:
        return 0.9  # High confidence, but maybe not 1.0 if it's a short substring? 0.9 is plenty to auto-play.
    
    # 4. Fuzzy match (fallback for typos, partial matches)
    matcher = difflib.SequenceMatcher(None, query, title)
    return matcher.ratio()

async def update_voice_status(channel, status):
    """Updates the voice channel status safely."""
    if channel and channel.permissions_for(channel.guild.me).manage_channels:
        try:
            # Discord has a limit, let's say 100 to be safe and readable
            if status and len(status) > 100:
                status = status[:97] + "..."
            await channel.edit(status=status)
        except Exception as e:
            print(f"Failed to update voice status: {e}")

def play_next(guild_id, vc, text_channel):
    # Reset skip votes for the new track
    guild_skip_votes[guild_id] = set()

    if guild_id in guild_queues and len(guild_queues[guild_id]) > 0:
        next_song = guild_queues[guild_id].pop(0)

        # Get default volume (0.0 - 1.0), defaulting to 0.6 (60%) if not set
        guild_id_str = str(guild_id)
        default_volume = guild_settings.get(guild_id_str, {}).get("default_volume", 60) / 100.0

        # Start playback
        source = discord.FFmpegPCMAudio(next_song['url'], **FFMPEG_OPTIONS)
        source = discord.PCMVolumeTransformer(source, volume=default_volume)
        
        # vc.play's "after" callback runs in a background thread, so we must use threadsafe calls
        vc.play(source, after=lambda e: bot.loop.call_soon_threadsafe(play_next, guild_id, vc, text_channel))

        # Send Now Playing message
        view = SkipButton(guild_id, vc)
        coro = text_channel.send(f"üé∂ **Now Playing:** {next_song['title']} (Vol: {int(default_volume*100)}%)", view=view)
        asyncio.run_coroutine_threadsafe(coro, bot.loop)

        # Update Voice Channel Status
        status_coro = update_voice_status(vc.channel, f"üé∂ {next_song['title']}")
        asyncio.run_coroutine_threadsafe(status_coro, bot.loop)
    else:
        # Queue is empty, leave channel
        # Clear status before leaving (or just leave, status might persist but that's okay, maybe clear it?)
        # Actually better to clear it if we can, but disconnecting might clear it automatically or leave it. 
        # Let's try to clear it explicitly first.
        status_coro = update_voice_status(vc.channel, None)
        asyncio.run_coroutine_threadsafe(status_coro, bot.loop)

        coro = vc.disconnect()
        asyncio.run_coroutine_threadsafe(coro, bot.loop)


# --- Commands ---
@bot.tree.command(name="play", description="Add a song to the queue (URL or search query).")
@app_commands.describe(query="The YouTube URL or search query")
async def play(interaction: discord.Interaction, query: str):
    await interaction.response.defer()

    if not interaction.user.voice:
        await interaction.followup.send("You need to join a voice channel first.")
        return

    channel = interaction.user.voice.channel
    guild_id = interaction.guild.id

    # Join or move to the correct voice channel
    vc = interaction.guild.voice_client
    if not vc:
        vc = await channel.connect()
    elif vc.channel != channel:
        await vc.move_to(channel)

    # Extract audio info in an executor to avoid blocking the bot's event loop
    ydl = yt_dlp.YoutubeDL(YTDL_OPTIONS)
    try:
        if not query.startswith('http'):
            # Use ytsearch5 to get up to 5 results for confidence checking
            search_query = f"ytsearch5:{query}"
            
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(None, lambda: ydl.extract_info(search_query, download=False))
            
            if 'entries' not in info or len(info['entries']) == 0:
                await interaction.followup.send("No results found.")
                return

            entries = info['entries']
            first_result = entries[0]
            first_title = first_result.get('title', 'Unknown Track')
            
            # Check confidence
            confidence = check_confidence(query, first_title)
            
            # If confidence is high (> 0.6) or only 1 result, play immediately
            if confidence > 0.6 or len(entries) == 1:
                stream_url = first_result['url']
                title = first_title
            else:
                # Low confidence: Show selection menu
                view = TrackSelectionView(entries, vc, interaction)
                await interaction.followup.send(f"Found multiple results for **{query}**. Please select one:", view=view)
                return

        else:
            # Direct URL handling
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(None, lambda: ydl.extract_info(query, download=False))
            
            if 'entries' in info:
                # Playlist or search result that returns entries
                if len(info['entries']) > 0:
                    info = info['entries'][0]
                else:
                    await interaction.followup.send("No results found.")
                    return

            stream_url = info['url']
            title = info.get('title', 'Unknown Track')

    except Exception as e:
        await interaction.followup.send(f"Failed to extract video data. It might be age-restricted or invalid.")
        return

    # Initialize queue if needed
    if guild_id not in guild_queues:
        guild_queues[guild_id] = []

    guild_queues[guild_id].append({'url': stream_url, 'title': title})

    if not vc.is_playing():
        await interaction.followup.send(f"Added to queue and starting: **{title}**")
        play_next(guild_id, vc, interaction.channel)
    else:
        await interaction.followup.send(f"Added to queue: **{title}**")


@bot.tree.command(name="playlist", description="List the current song queue.")
async def playlist(interaction: discord.Interaction):
    guild_id = interaction.guild.id
    if guild_id not in guild_queues or not guild_queues[guild_id]:
        await interaction.response.send_message("The queue is currently empty.", ephemeral=True)
        return

    queue = guild_queues[guild_id]
    view = PlaylistView(queue)
    await interaction.response.send_message(embed=view.create_embed(), view=view)


# --- Settings Group ---
music_channel_group = app_commands.Group(name="settings", description="Manage bot settings (Mods Only).", default_permissions=discord.Permissions(manage_guild=True))

@music_channel_group.command(name="skip_percent", description="Set the percentage of users required to skip (1-100).")
async def skippercent(interaction: discord.Interaction, percent: int):
    if percent < 1 or percent > 100:
        await interaction.response.send_message("Please provide a number between 1 and 100.", ephemeral=True)
        return

    guild_skip_percents[interaction.guild.id] = percent / 100.0
    await interaction.response.send_message(f"Skip requirement updated to **{percent}%** of the voice channel.", ephemeral=True)


@music_channel_group.command(name="default_volume", description="Set the default volume for music playback (1-200%).")
@app_commands.describe(volume="Volume percentage (1-200)")
async def defaultvolume(interaction: discord.Interaction, volume: int):
    if volume < 1 or volume > 200:
        await interaction.response.send_message("Please provide a volume between 1 and 200.", ephemeral=True)
        return

    guild_id_str = str(interaction.guild.id)
    if guild_id_str not in guild_settings:
        guild_settings[guild_id_str] = {}

    guild_settings[guild_id_str]["default_volume"] = volume
    save_settings()

    await interaction.response.send_message(f"üîä Default volume set to **{volume}%** for future tracks.", ephemeral=True)


@music_channel_group.command(name="set_music_channel", description="Set the home music channel.")
@app_commands.describe(channel="The voice channel to set as home.")
async def music_channel_set(interaction: discord.Interaction, channel: discord.VoiceChannel):
    guild_id_str = str(interaction.guild.id)
    if guild_id_str not in guild_settings:
        guild_settings[guild_id_str] = {}
    
    guild_settings[guild_id_str]["music_channel_id"] = channel.id
    save_settings()
    
    await interaction.response.send_message(f"‚úÖ Home music channel set to **{channel.name}**.", ephemeral=True)

@music_channel_group.command(name="clear_music_channel", description="Clear the home music channel setting.")
async def music_channel_clear(interaction: discord.Interaction):
    guild_id_str = str(interaction.guild.id)
    if guild_id_str in guild_settings and "music_channel_id" in guild_settings[guild_id_str]:
        del guild_settings[guild_id_str]["music_channel_id"]
        save_settings()
        await interaction.response.send_message("üóëÔ∏è Home music channel setting cleared.", ephemeral=True)
    else:
        await interaction.response.send_message("‚ÑπÔ∏è No home music channel was set.", ephemeral=True)

@music_channel_group.command(name="list_music_channels", description="List available voice channels and the current home channel.")
async def music_channel_list(interaction: discord.Interaction):
    guild_id_str = str(interaction.guild.id)
    current_channel_id = guild_settings.get(guild_id_str, {}).get("music_channel_id")
    
    embed = discord.Embed(title="Voice Channels", color=discord.Color.blue())
    
    description = ""
    found_current = False
    
    # Sort channels by position
    voice_channels = sorted(interaction.guild.voice_channels, key=lambda c: c.position)
    
    for vc in voice_channels:
        if current_channel_id and vc.id == current_channel_id:
            description += f"**üéôÔ∏è {vc.name} (Home)**\n"
            found_current = True
        else:
            description += f"üîä {vc.name}\n"
            
    if not description:
        description = "No voice channels found."
        
    embed.description = description
    
    if current_channel_id and not found_current:
        embed.set_footer(text="‚ö†Ô∏è The set home channel no longer exists!")
        
    await interaction.response.send_message(embed=embed, ephemeral=True)

bot.tree.add_command(music_channel_group)


@bot.event
async def on_voice_state_update(member, before, after):
    # Ignore bots
    if member.bot:
        return

    # Check if user joined a channel
    if after.channel is None:
        return

    # Check if we have a home channel set for this guild
    guild_id_str = str(member.guild.id)
    if guild_id_str not in guild_settings:
        return
        
    music_channel_id = guild_settings[guild_id_str].get("music_channel_id")
    if not music_channel_id:
        return

    # Check if the channel joined is the home channel
    if after.channel.id != music_channel_id:
        return

    # Check if the bot is already connected to a voice channel in this guild
    vc = member.guild.voice_client
    if vc and vc.is_connected():
        return # Already connected somewhere
        
    # Connect to the home channel
    try:
        await after.channel.connect()
        print(f"Auto-joined home channel: {after.channel.name} in {member.guild.name}")
    except Exception as e:
        print(f"Failed to auto-join home channel: {e}")


@bot.event
async def on_ready():
    load_settings()
    print(f"Logged in and ready as {bot.user.name}!")

if __name__ == "__main__":
    try:
        bot.run(TOKEN)
    except discord.errors.PrivilegedIntentsRequired:
        print("\n\n!!! CRITICAL ERROR: PRIVILEGED INTENTS REQUIRED !!!")
        print("You must enable both 'Message Content Intent' AND 'Server Members Intent' in the Discord Developer Portal.")
        sys.exit(2)